% Generated by roxygen2 (4.0.2): do not edit by hand
\name{wfgEval}
\alias{wfgEval}
\alias{wfgWrap}
\title{wfgEval evaluates a test function conforming to a given specification at a given point. \cr
wfgWrap creates a functor conforming to a given specification without evaluating it. \cr
wfgEval can be directly executed e.g. in a loop trying various parameters. \cr
wfgEvals return value can be given to optimization-algorithms.}
\usage{
wfgEval(z, num.objectives, spec, z.maxes = NA, num.pos.rel = NA,
  degen = FALSE, scales = NA, dist = NA, noise = 0,
  true.front = FALSE)

wfgWrap(num.objectives, spec, z.maxes = NA, num.pos.rel = NA,
  degen = FALSE, scales = NA, dist = NA, noise = 0,
  true.front = FALSE)
}
\arguments{
\item{z}{\cr
The point at which to evaluate the test function.}

\item{num.objectives}{\cr
The size of the output vector. (|out|<=|in|)}

\item{spec}{\cr
The specification of transformations, shapes and their parameters.\cr
specifically a vector or list with:}

\item{z.maxes}{\cr
This and all following parameters are optional. (If you use any of them, that you place them before giving the spec.) A vector containing the maximum for each in-dimension (the minima are always 0). default is all 1.}

\item{num.pos.rel}{\cr
The number of position-related parameters. For details refer to the paper (variable k).}

\item{degen}{\cr
Whether to degenerate the pareto frontier. Normally it is a hyperplane, this degenerates it by 1 dimension.}

\item{scales}{\cr
A vector of factors for the objectives.}

\item{dist}{\cr
A single distance scaling factor. In principle moving the evaluations away from the true pareto frontier.}

\item{noise}{\cr
The standard deviation of the multivariate normal distributed noise added on top.}

\item{true.front}{\cr
Whether to instead return the point on the true pareto frontier corresponding to the input.}
}
\value{
wfgEval: The vector of objective values. wfgWrap: a functor that can be given to optimization algorithms.
}
\description{
wfgEval evaluates a test function conforming to a given specification at a given point. \cr
wfgWrap creates a functor conforming to a given specification without evaluating it. \cr
wfgEval can be directly executed e.g. in a loop trying various parameters. \cr
wfgEvals return value can be given to optimization-algorithms.
}
\examples{
v2 = c(0.1, 0.2) # example input vectors
v3 = c(0.1, 0.2, 0.3)
v4 = c(0.1, 0.2, 0.3, 0.4)
v5 = c(0.1, 0.2, 0.3, 0.4, 0.5)
wfgEval(v3, 3, c(sConvex)) # specification to only evaluate the convex shape, no transformations
wfgEval(v3, 3, degen=TRUE, c(sConvex)) # recommended placing any optional parameters in front of the spec.
wfgEval(v3, 3, c(sLinear, 2, sMixed))  # the first parameter is the number of entries to apply the front to. the default is to apply to all remaining entries, except for mixed and disconnected fronts which can only transform a single entry.
wfgEval(v3, 3, c(sDisc, NA, 1.3, sLinear)) # order-based parameters can be given, in this case the overall shape is 1.3, the other parameters of the disconnected shape remain their defaults.
wfgEval(v3, 3, c(tFlat, 3, 0.9, 0.2, 0.5, sLinear)) # a transformation with order-based parameters (number of entries, value, from, to)
wfgEval(v3, 3, c(tDecept, aper=0.25, sLinear)) # named parameter (aperture size), all other parameters stay on default.
wfgEval(v3, 3, c(tPoly, alpha=0.02, tDecept, NA, 0.35, 0.001, 0.05, tMulti, 1, num.minima=30, tNonsep, sConvex, 1, sLinear)) # 4 transformations, 2 shapes. in this example all transformations are applied to all entries.
functor = wfgWrap(2, c(sLinear)) # the only difference in arguments is, that the first argument -the point z- is not provided
}

